This benchmark suite is adapted from the CMU PBBS benchmark suite, located
at http://www.cs.cmu.edu/~pbbs/index.html This README is inspired by the
README included with those benchmarks, and there are many similarities
between the two, but we felt it necessary to update the README to better
reflect the changes we made to the suite.

Assumptions:
	-The user is using the Cilkplus version of gcc/g++, located at
	 http://www.cilkplus.org/build-gcc-cilkplus
	-cilkplus-install is in the user's home directory
	-After generating the inputs, this suite will take up roughly 18GB of
	 space. Make sure you have sufficient room in your hard drive.

QUICK-START:
	1. Run make in the directory containing this README (the toplevel
	   directory)
	2. To run a taskset:
		1. cd into the runtime directory
		2. Run the following:
		   ./clustering_launcher <taskset_name>
		   where <taskset_name> is a .rtpt or .rtps file (but don't include
		   the .rtpt or .rtps when running with the clustering launcher).
		   Note: several example tasksets are included in the tasksets
		   directory within runtime. To create your own, see the 
		   documentation included with this suite.
	3. To run an individual benchmark (not in real-time):
		1. cd into benchmarks/<benchmark> where <benchmark> is the one you
		   want to run.
		2. cd into <benchmark>-omp or <benchmark>-cilkp, depending on
		   whether you want to run the OpenMP or Cilkplus version
		3. You can either run ./testInputs, which runs the benchmark on
		   several input files, or you can generate your own input files
		   using the instructions at
		   http://www.cs.cmu.edu/~pbbs/benchmarks.html
		   Then just run ./<bnchmrk> (the shortened version of <benchmark>
		   on the input file.

*****************************
DIRECTORY STRUCTURE
*****************************
Makefile:
	Makes all of the executable benchmarks and associated tasks, as well
	as the clustering launcher. Functions by running "make" in runtime and
	in the top level of each individual benchmark.
benchmarks:
    This directory contains the source code for all of the benchmarks and
	the task versions of them. Each directory (with the exception of nBody
	and DelaunayTriangulation, discussed below) has a common folder, a
	data generation folder, a floder containing a serial implementation of 
	the benchmark, and a Cilkplus and OpenMP implementation of each 
	algorithm, labeled as <benchmark>-cilkp and <benchmark>-omp 
	respectively. For descriptions of the contents of those folders, see
	the text below (largely taken from PBBS README).
runtime:
 	Contains everything necessary to run the clustering launcher, as well
	as the tasksets folder, which contains sample tasksets for each
	benchmark as well as tasksets that combine a few benchmarks.

*****************************
MAKING THE INPUT FILES
*****************************
After typing make, simply type "make inputs" in the toplevel directory (the
one containing this README) to make input files for use with the benchmarks
and tasksets. The inputs are labeled with their type and size, where the
sizes are as follows:
size6: n = 10,000,000
size5: n = 1,000,000
size4: n = 100,000
size3: n = 10,000
size2: n = 1,000
size1: n = 100
For more information on specific input types and uses, see the PBBS website
at http://www.cs.cmu.edu/~pbbs/index.html

*****************************
NOTES ON BENCHMARKS
*****************************
For descriptions of the specific benchmarks, including input and output, see
http://www.cs.cmu.edu/~pbbs/benchmarks.html

Note on DelaunayTriangulation:
	Only included in the suite because DelaunayRefine needs it to run. Not
	meant to be used by the real-time framework.

Note on nBody:
	Due to issues with OpenMP optimization [??], we did not include an
	OpenMP implementation of nBody.

Note on comparisonSort:
	For stlParallelSort, the folder might need to be named
	stlParallelSort-omp. It requires OpenMP to compile, but we are not
	sure if it's an OpenMP implementation.

<benchmark>/common:
    Code and other files that are common across implementations of the
    benchmark, e.g. the check code.

<benchmark>/common/<bnchmrk>Check.C:
	Code for checking the correctness of the output for the benchmark.
	<bnchmrk> is typically an abbreviation for <benchmark>, e.g. "isort" 
	is short for "integerSort", and hence the file 
	integerSort/common/isortCheck.C. Running "make" will typically make 
	the check file. It is then used in the form
	"<bnchmrk>Check <inputFile> <outputFile>".

<benchmark>/common/testInputs:
	A script that runs the benchmark on all the inputs.  This file
	includes the list of input files that are part of this benchmark.
	It is typically copied over to the directory for each implementation.

<benchmark>/common/<bnchmrk>Time.C:
	This is a driver for running the benchmark.  This can be used if the
	benchmark implementation code is written in C or can be linked with C.
	Otherwise the benchmark implementation might require its own driver.

<benchmark>/<implementation>/:
	These directories contain a particular implementation of the benchmark,
	for example "comparisonSort/sampleSort/".

<benchmark>/<implementation>/Makefile:
	Running "make" should make the benchmark code and generate a file
	called <bnchmrk>.  This includes linking in files from "common" and
	"benchmark/<common>" if needed.

<benchmark>/<implementation>/testInputs:
	This file might not be in the directory before the "make", but should
	be copied over by the make.  It is used to run the benchmark on all
	the test inputs and check the results for correctness.  The
	benchmark can also be run on its own on a single input without testing 
	by using <benchmark>/<implementation>/<bnchmrk> <infile>.  Here 
	<bnchmrk> is the same abbreviation as used in the common directory 
	(e.g. "isort"). For example in the directory 
	"comparisonSort/sampleSort", run:
	./sort ../sequenceData/data/randomSeq_10000000_double
	which will just print out the runtime, and perhaps some statistics,
	Using the -o option:
	./sort -o <fname> ../sequenceData/data/randomSeq_10000000_double
	will output the result to the file <fname>, which can then be tested
	with the check program:
	../common/<bnchmrk>Check ../sequenceData/data/randomSeq_10000000_double <fname>
	Note, however, that the input file might not exist, in which case
	go to the "data" directory and:
	make randomSeq_10000000_double

<benchmark>/<implementation>/<bnchmrk>Task.C:
	The source code for the the task that can be executed by the clustering
	launcher using a taskset. Largely rearranged code from <bnchmrk>Time.C.

